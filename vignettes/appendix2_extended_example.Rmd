---
title: 'Appendix 2: Extended Example'
subtitle: "Understanding mixed effects models through data simulation"
author: "Lisa M. DeBruine & Dale J. Barr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Appendix 2: Extended Example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, message=FALSE}
library("lme4")        # model specification / estimation
library("afex")        # deriving p-values from lmer
library("broom.mixed") # extracting data from model fits 
library("faux")        # data simulation
# NOTE: to install the 'faux' package, use:
# devtools::install_github("debruine/faux", build_vignettes = TRUE)
library("tidyverse")   # data wrangling and visualisation

# set options for display in this R Markdown file
knitr::opts_chunk$set(echo       = TRUE,
                      fig.width  = 8,
                      fig.height = 5,
                      out.width  = "100%")

set.seed(90210)
```

This script uses the `sim_design()` function in [faux](https://debruine.github.io/faux/) to create data tables with correlated random effects with specified parameters without needing to set up the correlation and variance matrices manually.

### Set Study Parameters

In this example, 100 subjects will respond twice (for happy and angry expressions) to 50 items; 25 items in each of 2 categories. In this example, `expression` is a within-subject and within-item factor and `category` is a within-subject and between-item factor.

We will set our grand intercept and the fixed effect of category the same as before (800 ms and 50ms). We will predict that classification speed will be faster for angry than happy outgroup faces, and faster for happy than angry ingroup faces. In other words, the effect of category will be bigger for happy faces than angry faces, but there will be no main effect of expression, just an interaction between category and expression, which we will set at 70 ms (the 50ms effect of category will be 35 ms bigger for happy faces and 35 ms smaller for angry faces).

Therefore, you will need to set up more complicated random effect parameters. Items and subjects will need standard deviations assigned for their random intercepts and the random slopes for any within factors (and their interactions), plus the correlations among all these SDs.

Since all subjects respond to all items, we can set up a table of trials by crossing the subject IDs with the item IDs and also any factors that are within-subject *and* within-item (i., `expression = c("happy", "angry")`). This is set up as a factor with the levels specified so they are displayed in the right order in plots.

```{r}

ext_sim_data <- function(
  nsubj        = 100, # number of subjects/btwn-grp
  nitem        =  25, # number of items/btwn-grp
  b0           = 800, # grand mean
  b_cat        =  50, # main effect of category
  b_exp        =   0, # main effect of expression
  b_cat_exp    =  70, # interaction between category and expression
  I0i_sd       =  80, # by-item random intercept sd
  Iexp_sd      =  60, # by-item random slope for exp
  icor         = 0.2, # by-item random effect correlation
  S0s_sd       = 100, # by-subject random intercept sd
  Scat_sd      =  40, # by-subject random slope sd for category
  Sexp_sd      =  80, # by-subject random slope sd for exp
  Scat_exp_sd  =  80, # by-subject random slope sd for category*exp
  # by-subject random effect correlations
  scor         = c(.3, .3, .3,   # S0s  * cat, exp, tc
                       .1, .1,   # cat  *      exp, tc
                           .1),  # exp *            tc
  err_sd       = 200   # residual (error) sd
) {

  # simulate items
  items <- faux::sim_design(
    within  = list(components = c("I0i", "Iexp")),
    between = list(category = c("ingroup", "outgroup")),
    n = nitem,
    sd = data.frame(I0i = I0i_sd, 
                    Iexp = Iexp_sd),
    r = icor,
    id = "item_id",
    plot = FALSE
  )

  # simulate subjects
  subjects <- faux::sim_design(
    within = list(components = c("S0s", "Scat", "Sexp", "Scatexp")), 
    n = nsubj,
    sd = c(S0s  = S0s_sd,
           Scat = Scat_sd, 
           Sexp = Sexp_sd, 
           Scatexp  = Scat_exp_sd), 
    r = scor,
    id = "subj_id",
    plot = FALSE
  )

  # simulate trials
  dat_sim <- crossing(
    subj_id = subjects$subj_id,
    item_id = items$item_id,
    expression = factor(c("happy", "angry"), ordered = TRUE)
  ) %>%
    inner_join(subjects, "subj_id") %>%
    inner_join(items, "item_id") %>%
    mutate(exp = recode(expression, "happy" = -0.5, "angry" = 0.5),
           cat = recode(category, "ingroup" = -0.5, "outgroup" = +0.5),
           trial_i    = b0 + I0i +  S0s,
           trial_cat  = b_cat + Scat,
           trial_exp  = b_exp + Iexp + Sexp,
           trial_ct   = b_cat_exp + Scatexp,
           err = rnorm(nrow(.), mean = 0, sd = err_sd),
           RT = trial_i + 
             (trial_cat*cat) + 
             (trial_exp*exp) + 
             (trial_ct*cat*exp) + err)
  
  dat_sim
}
```

Plot your data to double-check it looks like you expect.

```{r}
dat_sim <- ext_sim_data()

ggplot(dat_sim, aes(expression, RT, color = category)) +
  geom_boxplot(width = 0.25, position = position_dodge(width = 0.9))
```


### Analyse Data


```{r}
ext_sim_func <- function(...) {
  
  dat_sim <- ext_sim_data(...)
  
  mod_sim <- lmer(RT ~ 1 + cat*exp + 
                    (1 + exp | item_id) + 
                    (1 + cat*exp | subj_id),
                  data = dat_sim, REML = TRUE)
  
  broom.mixed::tidy(mod_sim)
}
```

Run the function once with default parameters. 

```{r}
ext_sim_func()
```

## Power Analysis

```{r, eval = FALSE}
reps <- 20

# runs each rep, combines them into one data frame,
# and then writes the results to a file
# if this crashes, you've lost everything
# sims <- purrr::map_df(1:reps, ~ext_sim_func())
# write_csv(sims, "sims/ext_sims.csv")

# write to file after each rep; more robust against crashes
replicate(reps, {
  # run 1 rep of the simulation
  sim <- ext_sim_func()
  # add column for date/time
  sim$date <- format(Sys.time(), "%Y-%m-%d %H:%M")
  # check if you need to write the header
  append <- file.exists("sims/ext_sims.csv")
  # write to a file
  write_csv(sim, "sims/ext_sims.csv", append = append)
})
```

```{r}
sims <- read_csv("sims/ext_sims.csv", col_types = cols(
  # makes sure plots display in this order
  group = col_factor(ordered = TRUE),
  term = col_factor(ordered = TRUE)
))
```

You can use these data to calculate power for each fixed effect or plot the distribution of your fixed or random effects.

```{r}
# calculate mean estimates and power for specified alpha
alpha <- 0.05

sims %>% 
  filter(effect == "fixed") %>%
  group_by(term) %>%
  summarise(
    mean_estimate = mean(estimate),
    mean_se = mean(std.error),
    power = mean(p.value < alpha),
    .groups = "drop"
  )
```

```{r, fig.cap = "Distribution of fixed effects across simulations"}
sim_stats <- sims %>% 
  filter(effect == "fixed") %>%
  group_by(term) %>%
  summarise(
    value = mean(estimate),
    .groups = "drop"
  )

sims %>%
  filter(effect == "fixed") %>%
  ggplot() +
  geom_density(aes(estimate, y = ..count.., fill = term), 
               alpha = 0.5, show.legend = FALSE) +
  geom_vline(data = sim_stats, aes(xintercept = value), 
             color = "grey40", show.legend = FALSE) +
  facet_wrap(~term, ncol = 2, scales = "free_x") + 
  theme_bw()
```



```{r, fig.height = 10, fig.cap = "Distribution of random effects across simulations"}

sim_stats <- sims %>%
  filter(effect == "ran_pars") %>%
  group_by(group, term) %>%
  summarise(value = mean(estimate),
            .groups = "drop")

sims %>%
  filter(effect == "ran_pars") %>%
  ggplot(aes(estimate, fill = group)) +
  geom_density(alpha = 0.5, show.legend = FALSE) +
  geom_vline(data = sim_stats, aes(xintercept = value),
             show.legend = FALSE) +
  facet_wrap(~group*term, ncol = 3, scales = "free") + 
  theme_bw()
```













